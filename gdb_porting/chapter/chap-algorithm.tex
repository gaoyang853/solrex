
\chapter{\texttt{GDB}~的内部算法}
\label{chap:algorithm}

\texttt{GDB}~有很多状态转移和内部执行逻辑的算法，下面简单介绍一下几个最基础的算法：

\section{\texttt{GDB}~的启动}

~\texttt{GDB}~是一个用户交互软件，下面简单地看一下~\texttt{GDB}~在启动时做了些什么：

(1)处理命令行传入的参数，并由此设置一些对运行产生影响的变量。比如：~\texttt{GDB}~标准输入输出和标准错误输出的文件描述符，用户界面，执行文件的参数，脚本的文件路径等等，可以使用~\texttt{"gdb --help"}~来查看所有可能的参数。

(2)调用各种初始化函数来对调试器进行初始化。初始化的内容包括：命令列表，目标处理机宏定义，工具函数，所有文件，当前计算机体系架构，命令行解释器，串行输入，信号处理函数，源程序语言，用户界面等。由于~\texttt{GDB}~本身的可扩展和可移植性，它定义很多通用的工具函数接口，需要开发人员把具体的实现注册到~\texttt{GDB}~内部的指针变量或者定义为相应的宏，这样~\texttt{GDB}~就可以采用同样的接口来使用这些函数和变量的不同实现。

(3)根据第一步设置的变量并使用第二步初始化后注册的函数来执行一些相应的动作，然后转移控制权。比如打印出~\texttt{GDB}~的版本信息，打印出当前时间，执行相应的脚本文件等等，执行完这些动作以后~\texttt{GDB}~会直接退出或者进入命令循环，等待用户的输入。

\section{\texttt{Frame}~模型}

~\texttt{Frame(stack frame)}~模型是~\texttt{GDB}~用来确定函数的调用和被调用历史的采用的模型。它的理论基础已经在上文中讲过，其最初的设计是为了支持~\texttt{DWARF}~调试信息格式里的~\texttt{CFI(call frame information)}~。~\texttt{GDB}~的~\texttt{frame}~模型是这样的：每个~\texttt{frame}~与一个函数对应，当前~\texttt{PC(program counter)}~所处函数的~\texttt{frame}~为第0层，此~\texttt{frame}~的上一层就是此函数调用者的~\texttt{frame}，就这样一级一级往上回滚~\texttt{(unwind)}，就可以构造出整个函数调用的历史。在~\texttt{GDB}~内部是通过构建链表数据结构来实现的。在~\texttt{GDB}~调试时查看函数的~\texttt{backtrace}~就是此模型的一个外部表示。当然此模型还有很多用处，比如从被调用者中返回，从函数中跳出，步过一个函数，都需要此模型来判断程序的中断位置。在这里还有一个重要的特殊的~\texttt{frame}，叫做~\texttt{sentinel frame}，即第-1层~\texttt{frame}，定义此~\texttt{frame}~的目的是为了回滚得到当前(第0层)~\texttt{frame}，这是整个~\texttt{unwind frame}~过程的开始，是回滚得以正常进行的关键。\texttt{GDB}~会使用~\texttt{create\_sentinel\_frame}~函数，根据~\texttt{prologue}~分析得到的寄存器信息来创建这个~\texttt{frame}。

\section{~\texttt{Prologue}~分析}

\texttt{Function prologue}~指的是在目标文件中，位于每个函数开头的为该函数准备好栈空间和保存寄存器的机器代码，其行为主要包括将一些重要寄存器保存进栈，移动栈寄存器指针为当前函数留出堆栈空间。当函数执行完毕后，对应的~\texttt{epilogue}会做相反的事情以把处理机环境恢复到函数调用前的状态。\texttt{prologue}~分析主要是为构建~\texttt{frame trace}~服务的，~\texttt{GDB}~必须知道各个~\texttt{frame}~的基址和偏移量才能决定某个地址位于哪个~\texttt{stack frame}~中，而且~\texttt{GDB}~必须知道在进入函数时都对哪些寄存器做了什么修改，才可以通过分析得到正确的寄存器内容，而且回滚到正确的~\texttt{frame}~。如果编译器能产生正确的~\texttt{DWARF}~调试信息，那么其中的~\texttt{CFI}~就能够给出足够的信息，只需读取相应的内容即可，否则就需要使用\texttt{prologue}~分析来得到这些信息。

~\texttt{Prologue}~分析主要采用的方法是从函数入口开始检测一定范围的机器指令，分析其中每条指令对寄存器的修改。例如：寄存器内容压栈，转移到另外的寄存器等等，然后将这些修改进行汇总，以得出此函数的~\texttt{prologue}~对寄存器和堆栈的修改，并将这些修改保存在一个~\texttt{register cache}~结构中，以供构建~\texttt{frame}~列表的函数使用。有的还顺便返回分析得到的函数的第一条表达式语句的地址来达到~\texttt{skip prologue}~的目的。

\section{断点处理}

断点~\texttt{breakpoint}~是指用户指定程序中的某个位置，当程序运行到这个位置时会中断执行，把目标处理机控制权重新转交给调试者。实际使用中主要有两种方法来实现断点功能，一种叫做硬断点，另一种叫做软断点。硬断点是指目标处理机硬件支持断点功能(或者在目标处理机模拟器上支持断点功能)，可能的实现情况是目标处理机有一个专门存放断点的寄存器，当~\texttt{PC}~和这个寄存器内容一样时，目标处理机会产生一个异常，异常处理函数会把当前处理机状态通报给~\texttt{GDB}~；软断点是指目标处理机不支持硬件断点，需要~\texttt{GDB}~采用其它方法来实现断点功能。一般在这种情况下，\texttt{GDB}~会把内存中需要中断位置的指令修改为一条中断指令或者其它可以使目标处理机产生某种异常的指令，当程序运行到这一位置，执行这条指令后，目标处理机会捕获异常，进入相应的异常处理函数，异常处理函数会把状态通报给~\texttt{GDB}~。需要注意的一点是，这种情况下必须要程序在目标处理机上的存储空间可写，否则无法实现软中断。

不过，上面仅仅是从理论上分析了~\texttt{GDB}~的断点机制，在当前版本的~\texttt{GDB}~中，尤其是在跨平台调试的过程中，\texttt{GDB}~可以把断点功能下放给芯片上的~\texttt{GDB stub}~或者~\texttt{gdbserver}~进行处理。~\texttt{GDB}~仅仅告诉目标机上的程序在哪个地方设置断点，而由目标机上的程序实现断点功能。虽然有专门的协议格式规定哪些是硬件断点，哪些是软件断点，但具体的实现方式完全可以由~\texttt{GDB stub}~和~\texttt{gdbserver}~自己决定。

\section{单步执行}

这里的单步执行~\texttt{(single stepping)}~有两个方面的理解：单步跨过一行源程序和单步跨过一条机器指令，然后中断程序执行，将处理机控制权转交给调试者。单步跨过一行源程序是通过分析调试信息~\texttt{SAL}~来实现的，~\texttt{SAL}~里标明了源程序的行和机器指令的对应关系，\texttt{GDB}~会在下一行源程序的开始设置断点来实现单步跨过源程序。单步跨过一条机器指令也有两种实现方式，类似于断点，分为硬单步和软单步。硬单步一般是目标处理机支持单步执行的功能；软单步是由~\texttt{GDB}~通过分析当前指令设置相应断点来实现单步的功能。~\texttt{GDB}~首先读取~\texttt{PC}~所指向的指令，如果当前指令是一条一般指令，\texttt{GDB}~就在当前指令的下一条指令处插入断点；如果当前指令是一条分支或跳转类指令，\texttt{GDB}~通过指令集定义对指令解码，分析出它将要跳转的位置，然后在那个位置插入断点。

\section{信号处理}

信号是指在程序运行过程中发生的一些不可预料的事件。操作系统会将程序运行过程中可能产生的各种信号编号，并赋予有些信号相应的名字。~\texttt{GDB}~可以检测到被调试程序运行过程中产生的信号，并可以由用户自定义特定信号的处理方法；目标机也可以接受~\texttt{GDB}~传给它的信号。用户可以使用~\texttt{info handle}~命令查看各个信号的处理方法。

但是在一般情况下，目标机只会实现少量几种信号，并且这些信号和~\texttt{GDB}~的信号向量列表并不保证能一一对应。这样就需要目标机上的处理程序或者~\texttt{GDB}~自身进行转换，这个过程并不复杂。

\section{线程处理}

在拥有线程机制的操作系统上运行的程序，使用~\texttt{GDB}~调试时，可以在线程之间进行切换并访问对应资源。~\texttt{GDB}~会根据目标机返回的信息来构建线程列表，并以线程编号为索引保存各个线程对应的信息。因为线程之间共享内存和系统资源，~\texttt{GDB}~只需要保存进程对应的堆栈和PC等一些简单的信息，这些信息体现为~\texttt{gdbthread.h}~中的~\texttt{thread\_info}~结构。所以这个处理也比较简单，~\texttt{GDB}~源程序文件~\texttt{thread.c}~中定义了线程处理的相关函数。

由于~\texttt{GDB}~中的线程机制是指软件线程，在当前版本的~\texttt{GDB}~中并没有实现硬件线程，所以在向某些多线程处理器移植时，会采用欺骗~\texttt{GDB}~，用软件线程模拟硬件线程的方法来实现硬件多线程调试。

\section{内部函数调用}

内部函数调用~\texttt{(inferior function call)}~是指~\texttt{GDB}~手动调用某个函数，而效果像是在程序的当前位置执行一条函数调用语句。为了实现完全仿真，内部函数调用必须使用到程序的堆栈和数据区而当返回后又不能影响程序的正常运行，所以~\texttt{GDB}~需要做到的是在调用前保存处理机和内存现场，然后给函数传入正确的参数和返回地址进行调用，在调用后恢复处理机和内存现场。它的实现方式是调用和目标机相关代码设置函数调用的参数和返回地址，在返回地址上设置内部断点，修改~\texttt{PC}~到函数的入口地址开始执行调用，当程序执行到此断点时得到函数返回值并将对寄存器的所有修改进行回滚。函数内部对数据区的修改是不可恢复的，因为~\texttt{GDB}~并不可知其操作，~\texttt{GDB}~只恢复寄存器到原始状态，因为函数参数和返回值保存的位置都是寄存器和堆栈，而将堆栈指针恢复到原始位置就能取消所有对堆栈的修改。

不过内部函数调用还需要做一些其它的事情，例如处理函数参数。~\texttt{C}~语言中会对参数类型进行自动转换，~\texttt{K\&R}~风格就需要将所有~\texttt{float}~类型的参数转换成~\texttt{double}~类型,而~\texttt{prototype(ANSI C)}~风格就不做此转换。此外还需要找到函数的入口地址，确定返回地址。这些工作所依赖的函数和数据结构可以在~\texttt{infcall.h/c}~中找到。

\section{长跳转支持}

长跳转~\texttt{(longjmp)}~是~\texttt{C}~语言的一种机制，它绕过了一般函数的调用和返回规则。在~\texttt{C}~头文件~\texttt{setjmp.h}~中有一个依赖于目标机的结构体~\texttt{jmp\_buf}。这个机制的体现是先定义一个~\texttt{jmp\_buf}~类型变量~\texttt{buf}，调用~\texttt{setjmp(buf)}~函数时会把现场保存在变量~\texttt{buf}~里，当程序的继续执行遇到~\texttt{longjmp(buf, value)}~时候，程序会根据~\texttt{buf}~的内容跳转回最近的一个~\texttt{setjmp}~函数调用的位置，其效果相当于执行~\texttt{setjmp()}~这个函数，其返回值是~\texttt{value}。\cite{cstd}

\texttt{GDB}~内部对长跳转的支持是通过设置一些特殊的内部断点来实现的。因为~\texttt{jmp\_buf}~的结构和具体的计算机体系架构有关，\texttt{GDB}~先读取一些~\texttt{symbol}，即：\texttt{longjmp, \_longjmp, siglongjmp, \_siglongjmp}~的内容，然后用当前~\texttt{CPU}~体系架构依赖代码注册的~\texttt{GET\_LONGJMP\_TARGET}~宏或者~\texttt{gdbarch\_get\_longjmp\_target}~函数来得到要跳转到的位置，在这些位置设置内部断点以达到对长跳转的支持。由于这些断点不是调试者设置的，因此在正常的调试过程中是不可见的，但可以用提供给~\texttt{GDB}~维护者的命令~\texttt{"maintenance info breakpoints"}~查看。

\section{观察点}

观察点~\texttt{(watchpoints)}~指的是一种设置在数据区的断点，当设置观察点的数据被访问时，程序会产生中断。和断点一样，观察点也分为硬观察点和软观察点。硬观察点和断点基本没有什么不同，当数据区的数据被访问时，\texttt{CPU}~自动产生中断并向~\texttt{GDB}~报告自己的状态；但软观察点和软断点就有很大不同了。因为~\texttt{GDB}~不应该去修改数据区的内容，那样会影响程序的执行，所以~\texttt{GDB}~只能采取一种很笨的做法，就是单指令运行，在每次停顿查看和比较一下设置观察点位置的数据是否被修改。但需要注意的一点是，对于读取和访问类型的观察点，\texttt{GDB}~需要硬件的支持，因为~\texttt{GDB}~在外部只能比较数据是否被修改，而不能得到数据是否被访问和读取的信息。

\section{检查点}

从概念上来讲，检查点~\texttt{(checkpoints)}是~\texttt{GDB}~保存程序调试期状态的一种机制，调试者可以回到设置检查点的位置重新从那里开始调试程序。在支持进程机制的~\texttt{Linux}~系统下，一般设置检查点就是挂起当前进程，并根据当前进程状态创建一个新进程继续运行。但是在调试嵌入式系统的程序时，由于资源的限制性，不太容易做到这一点，比较简单的情况是嵌入式芯片的模拟器支持保存状态的功能，这样在进行模拟器调试的时候~\texttt{GDB}~就可以利用这些来方便的进行检查点的设置。如果目标机上不能运行支持进程机制的操作系统，~\texttt{GDB}~还没有有效的方法来实现检查点机制。这个功能在~\texttt{GDB}~的当前发行版中还不够成熟。
